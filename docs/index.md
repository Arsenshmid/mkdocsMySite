# Описание процесса хеширования и построения дерева Меркла

## Импорт библиотек
Для работы скрипта используются следующие модули:
- `json` — для чтения и работы с JSON-файлами.
- `hashlib` — для генерации хэшей с использованием алгоритма SHA3-256.

```python
import json
import hashlib
```

## Определение функции хеширования
Функция `sha3_myFunc(data)` принимает строку `data` и возвращает её хэш, закодированный с помощью алгоритма SHA3-256 в шестнадцатеричной системе.

```python
def sha3_myFunc(data):
    """Функция для хэширования строки данных с использованием SHA3-256."""
    return hashlib.sha3_256(data.encode()).hexdigest()
```

## Чтение и сортировка данных
Загружаем содержимое JSON-файла `tx.json` в переменную `data`, которая является списком словарей. После этого сортируем данные по ключу `block`.

```python
# Чтение данных из файла JSON
with open('tx.json', 'r') as file:
    data = json.load(file)

# Сортировка данных по полю 'block'
sortedData = sorted(data, key=lambda x: x['block'])
```

## Проверка на четность
Если количество элементов в отсортированном списке нечетное, дублируем последний элемент, чтобы сделать количество элементов четным. Это важно для корректной работы при построении дерева.

```python
# Дублирование последнего элемента, если количество нечетное
if len(sortedData) % 2 != 0:
    sortedData.append(sortedData[-1])  # Добавляем последний элемент повторно
```

## Построение дерева хэшей
Процесс продолжается, пока не останется один элемент — корневой хэш. Каждый уровень дерева создается путем объединения хэшей пар элементов из предыдущего уровня. Если парного элемента нет, последний элемент дублируется.

### Шаги процесса:
1. Создаем новый список `new_hashes` для хранения хэшей нового уровня.
2. Проходим по списку парами:
   - Если у элемента есть пара, создается хэш объединенных хэшей пары.
   - Если элемента без пары нет, его хэш дублируется.
3. Обновляем список для следующего уровня и повторяем процесс.

```python
# Построение дерева хэшей
while len(sortedData) > 1:
    # Список для хэшей следующего уровня
    new_hashes = []

    # Проход по элементам парами
    for i in range(0, len(sortedData), 2):
        if i + 1 < len(sortedData):
            # Объединяем хэши пары
            combined = sha3_myFunc(sortedData[i]['hash'] + sortedData[i + 1]['hash'])
        else:
            # Дублируем последний элемент, если нет пары
            combined = sha3_myFunc(sortedData[i]['hash'] + sortedData[i]['hash'])

        # Добавляем хэш на новый уровень
        new_hashes.append({'hash': combined})
    
    # Переходим к следующему уровню дерева
    sortedData = new_hashes
```

## Вывод корневого хэша
После завершения процесса выводится корневой хэш дерева Меркла, который является итоговым результатом объединения всех предыдущих хэшей.

```python
# Вывод корневого хэша дерева Меркла
print(sortedData[0]['hash'])
```

## Заключение
Этот процесс построения дерева хэшей напоминает структуру дерева Меркла. Каждый уровень объединяет хэши пар элементов предыдущего уровня, пока не останется один элемент — корневой хэш, который может быть использован для верификации целостности данных.

### Пример структуры данных
Для корректной работы скрипта данные в файле `tx.json` должны иметь следующую структуру:

```json
[
    {"block": 1, "hash": "abc123"},
    {"block": 2, "hash": "def456"},
    ...
]
```